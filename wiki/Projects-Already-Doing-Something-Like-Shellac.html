  <!DOCTYPE html>
  <html>
    <head>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Projects Already Doing Something Like Shellac</title>
      <link rel="stylesheet" type="text/css" href="../web/base.css" />
    </head>
    <body class="width40">

<p>Back: <a href="Shell-Autocompletion.html">Shell Autocompletion</a> / <a href="Shellac-Protocol-Proposal.html">Shellac Protocol Proposal</a></p>
<ul>
<li>https://github.com/szermatt/emacs-bash-completion</li>
<li>https://github.com/xonsh/xonsh/blob/master/xonsh/completers/bash_completion.py</li>
<li>Closh (Clojure shell) gets completions from bash, zsh, and fish!
<ul>
<li>https://github.com/dundalek/closh/tree/master/scripts/completion</li>
</ul>
</li>
<li>A wrapper around bash completion to export completion to zsh: https://github.com/curusarn/bash-complete-api
<ul>
<li><em>openstack does not have a completion for zsh.  This is how I used bash-complete-api to create zsh completion for openstack:</em></li>
<li>(From Simon Let via e-mail)</li>
</ul>
</li>
</ul>
<p>Other projects</p>
<ul>
<li><a href="https://news.ycombinator.com/item?id=19950563">shell_completion</a> in Rust is not a flag parser, but a shim that allows you to write completion plugins in Rust rather than bash.</li>
<li>https://github.com/rsteube/carapace-bin</li>
</ul>
<h2>Other protocols</h2>
<ul>
<li>https://shellcomp.github.io/ -- <em>Shellcomp is a simple standard to perform completion. Completion is implemented in the command about to be run: The shell runs the command with a specific --tabcomplete '&lt;partial_string&gt;' option. The command responds with simple JSON structure that the shell will parse to perform completion or display help messages.</em></li>
</ul>
  </body>
</html>

