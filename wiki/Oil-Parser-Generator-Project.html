  <!DOCTYPE html>
  <html>
    <head>
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <title>Oil Parser Generator Project</title>
      <link rel="stylesheet" type="text/css" href="../web/base.css" />
    </head>
    <body class="width40">

<p>(Back to <a href="Tasks-Under-NLNet-Grant.html">Tasks Under NLNet Grant</a>)</p>
<p>This is an introduction to an important subproject of https://www.oilshell.org/</p>
<p>(Note that we also need help on the Python-to-C++ translator.  This work is <strong>separate</strong> from that.  It involves parsing, but otherwise isn't strictly related.)</p>
<h2>Description</h2>
<p>Oil is developed <a href="https://www.oilshell.org/blog/2022/03/middle-out.html">&quot;middle out&quot;</a> -- it has an &quot;executable spec&quot; in Python, which is then semi-automatically translated to C++.</p>
<p>Much of the code works in C++, but the <strong>expression parser</strong> does not.  It's something of a special case.</p>
<p>Oil borrows the parsing approach of <strong>CPython</strong>, which is LL parsing (in the same family as ANTLR.)  Background: <a href="http://python-history.blogspot.com/2018/05/the-origins-of-pgen.html">The origins of pgen</a> by Guido.</p>
<hr />
<p>In Oil's Python implementation, the <code>oil_lang/grammar_gen.py</code> tool reads the grammar <code>oil_lang/grammar.pgen2</code>.  It produces parse tables in Python's &quot;marshal&quot; format.  At runtime, the <code>pgen2/</code> library reads it.</p>
<p>So instead of outputting these Python data structures, we want to output <strong>C data structures</strong> just like Python itself does it.  (before Python 3.8, when they switched to PEG.)</p>
<p>We want the <code>pgen-native/</code> <strong>parser runtime</strong> to be linked into the Oil executable.  It should</p>
<ol>
<li>Take input from Oil's lexer</li>
<li>Parse the token stream, using the generated parse tables.  This produces a parse tree.</li>
<li>We have separate code to translate the parse tree to an AST, which can be <strong>pretty printed</strong> using the <code>bin/oil -n</code> flag (see below).</li>
</ol>
<ul>
<li><a href="https://github.com/oilshell/oil/issues/594">Issue 594: Generate Parse Tables for pgen-native, and integrate it into oil-native</a>.  This is part of the translation to C++.  Right now we only have a slow parser in Python for the Oil expression language.</li>
</ul>
<h2>Background</h2>
<p><a href="https://www.oilshell.org/blog/2019/02/07.html">How to Parse Shell Like a Programming Language</a> explains our parsing approach.  This already works in Python:</p>
<pre><code>$ bin/oil --ast-format text -n -c 'echo &quot;hello $name&quot;'
(command.Simple
  words: [
    (compound_word parts:[(Token id:Id.Lit_Chars span_id:0 val:echo)])
...
</code></pre>
<p><strong>And</strong> it's already translated to C++:</p>
<pre><code>$ _bin/cxx-dbg/osh_eval  -n -c 'echo &quot;hello $name&quot;'
(command.Simple
  words: [
    (compound_word parts:[(Token id:Id.Lit_Chars span_id:0 val:echo)])
...
</code></pre>
<p>This part does <strong>not</strong> use pgen2, because it's just shell.  The Oil language has a <code>var</code> keyword, and that parse uses pgen2:</p>
<pre><code>~/git/oilshell/oil$ bin/oil --ast-format text -n -c 'var x = 1 + 2 * 3'
(command.VarDecl
  keyword: (Token id:Id.KW_Var span_id:0 val:var)
  lhs: [(name_type name:(Token id:Id.Expr_Name span_id:2 val:x))]
  rhs: 
    (expr.Binary
      op: (Token id:Id.Arith_Plus span_id:8 val:_)
      left: (expr.Const c:(Token id:Id.Expr_DecInt span_id:6 val:1))
      right: 
        (expr.Binary
</code></pre>
<p>However it crashes in C++:</p>
<pre><code>$ _bin/cxx-dbg/osh_eval --ast-format text -n -c 'var x = 1 + 2 * 3'
osh_eval: cpp/pgen2_parse.cc:8: void parse::Parser::setup(int): Assertion `0' failed.
Aborted (core dumped)
</code></pre>
<p>So this is what we want to work.</p>
<h2>Data Snippets</h2>
<pre><code>~/git/oilshell/oil/Python-2.7.13$ head -n 15  Python/graminit.c 
/* Generated by Parser/pgen */

#include &quot;pgenheaders.h&quot;
#include &quot;grammar.h&quot;
PyAPI_DATA(grammar) _PyParser_Grammar;
static arc arcs_0_0[3] = {
    {2, 1},
    {3, 1},
    {4, 2},
};
static arc arcs_0_1[1] = {
    {0, 1},
};
static arc arcs_0_2[1] = {
    {2, 1},
</code></pre>
<h2>Acceptance Tests</h2>
<p>These test run against Python, but I can make them run against C++ (the .asan variant).</p>
<pre><code>$ oil_lang/run.sh soil-run
</code></pre>
<h2>Relevant Files</h2>
<ul>
<li><a href="https://github.com/oilshell/oil/blob/master/cpp/pgen2_parse.cc">cpp/pgen2_parse.cc</a> -- where the code currently hits <code>assert(0)</code> if you try to parse Oil code.
<ul>
<li>This is a translation of <a href="https://github.com/oilshell/oil/blob/master/pgen2/parse.py">pgen2/parse.py</a>!</li>
</ul>
</li>
<li><code>oil_lang/grammar.pgen2</code> -- the grammar</li>
<li><code>oil_lang/grammar_gen.py</code>
<ul>
<li>this currently generates Python data structures, but we want to generate C data structures, like Python's <code>pgen.c</code> does</li>
<li>Python data structures: <code>_devbuild/gen/grammar.marshal</code> and <code>_devbuild/gen/grammar_nt.py</code>  (non-terminals)</li>
</ul>
</li>
<li><code>oil_lang/expr_parse.py</code> -- a wrapper for the generated parser</li>
<li>The <code>pgen2/</code> directory
<ul>
<li>parse.py and more</li>
</ul>
</li>
<li><code>pgen-native/</code> dir -- this is just a copy of Python, imported by a contributor</li>
<li><code>test/parse-errors.sh</code> -- this can be used as an acceptance test.
<ul>
<li>it is run in the continuous build in Python and C++ : http://travis-ci.oilshell.org/github-jobs/
<ul>
<li><code>dev-minimal &gt; parse-errors</code></li>
<li><code>cpp &gt; parse-errors</code></li>
</ul>
</li>
<li>Right now there are <code>if _is-oil-native</code> guards to prevent the <code>assert(0)</code> from failing in C++!</li>
</ul>
</li>
</ul>
<h2>Related</h2>
<ul>
<li><a href="Oil-Native-Quick-Start.html">Oil Native Quick Start</a></li>
<li><a href="Oil-Dev-Tips.html">Oil Dev Tips</a> -- shows examples of the parse tree and AST</li>
</ul>
  </body>
</html>

